# -*- coding: utf-8 -*-
"""
Created on Wed Dec 21 11:40:05 2016

@author: User
"""
 
import spidev
import time
import os

# Open SPI bus
spi = spidev.SpiDev()
spi.open(0,0)
 
# Function to read SPI data from MCP3008 chip
# Channel must be an integer 0-7
def ReadChannel(channel):
  adc = spi.xfer2([1,(8+channel)<<4,0])
  data = ((adc[1]&3) << 8) + adc[2]
  return data

from converter import ConvertVolts
from calculator import addUp, average
# Define sensor channels
# light_channel = 0
# temp_channel  = 1

# --Ryan adding one more channel for the ir sensors
#ir_channel = 2
ir_channel = 0
 
# Define delay between readings
delay = 5

#Try rewriting these to use coconut more if  I need them because results are so consistent that I probably won't


  # total += items.pop()
  # return addUp(items, total)


# def normalize(data, arg, repetitions = 100, result =[]):
  
#   if repetitions == 0:
      
#       # do not refactor because lists are immutable and addup treats them as stack so length becomes 0
#       length = len(result) 

#        # in case no reads occur
#       if length == 0:
#         return 0

#       total = addUp(result)
      
#       average = total / length
    
#       print("sum: ", total,"average: ", average)
#       return average
  
#   read = data(arg)

#   if read >= 0:
#     print( "repetitions: ", repetitions, "read: ", read)
#     result.append(read)

#   return normalize(data, arg, repetitions -1, result)


  

from distance_sensor import ConvertDistance

def repeat(data, repetitions, result = []):
  
  if( repetitions == 0):
    return result
  
  addItem = result.append .. list
  repeat( data, repetitions - 1, addItem(data)) 
  

def print_distances(channels):
  #--Ryan Read the distance data
    
    times_100 = repeat$(100)

    print_data = format_data .. average

    extract = times_100 .. map

    levels = extract <*| (ReadChannel, channels)

    print("levels: ", levels)

    volts = extract <*| (ConvertVolts, levels)

    print("volts: ", volts)

    distances = extract <*| (ConvertDistance, volts)

    print("distances: ", distances)
    
    print_data <*| ( channels, levels, volts, distances )



  # if channel == 3
  #   return

 


  # level = ReadChannel(channel)
  # volts = ConvertVolts(level)
  # distance = normalize <*| (ConvertDistance, volts)

  # getData = ConvertDistance .. ConvertVolts .. ReadChannel

  # format_data(channel, level, volts, data)

  # print_distances(channel + 1)


def format_data(channel, data, level, volts):
  print <| "Distance {}: {} ({}V) {} cm".format(channel, level, volts, data)


while True:

  get_time = time.asctime .. time.localtime .. time.time
 
  # Print out results
  print <| "--------------------------------------------"

  # print distances using channels 1 - 3 ( 0 - 2 in programmatic counting)
  print_distances <| range(3)
  
  print("Time: " + get_time())
 
  # Wait before repeating loop
  time.sleep(delay)
